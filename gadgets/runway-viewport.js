/*==============================================================================
| Runway Viewport (Renderer)
| File: gadgets/runway-viewport.js
| Tabs: hard tabs
|
| 1) Purpose
|   - Display either:
|       (a) a blended slice from providers (e.g., Civil + PrayerTimes), or
|       (b) a run (anchors generated by ChronusRunner).
|
| 2) Modes
|   - mode: 'blend' (default) → uses Chronus blended list for active context/frame.
|   - mode: 'run' → expects an injected anchors array (or a function) via window.RUNWAY_FEED().
|
| 3) UI
|   - Title + fineprint (city/method/tz).
|   - List of anchors for the active frame.
|   - CURRENT row gets ▷/▶ and inline "⌛ Time left: H:MM:SS" until NEXT.
|
| 4) Integration
|   - Subscribes to: chronus.blend.update, chronus.anchor.tick,
|     chronus.cursor.change, chronus.context.change
|   - Providers live elsewhere; this gadget is a pure renderer.
|
| ★ Future hooks
|   - Progress bars for day/week windows.
|   - Grouping by category (civil/prayer/run).
|
| HISTORY
|   v0.3.1  (#041)  Fix “Load error” by:
|     - Building DOM before touching fineEl/listEl
|     - Removing early state/context references
|     - Centralising Chronus context bootstrap + frame defaults
==============================================================================*/
(function(){
	if (!window.GADGETS) window.GADGETS = {};

	function pad2(n){ return (n<10?'0':'')+n; }

	function resolveSlots(anchors, now){
		const seq = (anchors||[]).slice().sort((a,b)=>a.at-b.at);
		let current=null, next=null, prev=null, phase='between'; // 'pre' | 'between' | 'post'

		for (let i=0;i<seq.length;i++){
			const a = seq[i];
			if (a.at <= now) { prev = a; current = a; }
			if (a.at >  now) { next = a; break; }
		}
		if (!current && seq.length){          // before the first anchor (e.g., pre-Fajr)
			phase   = 'pre';
			current = seq[0];                  // show the first as the “current/upcoming”
			next    = seq[1] || null;          // (optional) second one
		} else if (current && !next) {        // after the last anchor
			phase   = 'post';
		}
		return { seq, prev, current, next, phase };
	}

	function fmtHMS(sec){
		const s = Math.max(0, sec|0);
		const h = Math.floor(s/3600);
		const m = Math.floor((s%3600)/60);
		const ss = s%60;
		return `${h}:${pad2(m)}:${pad2(ss)}`;
	}

	// Safe JSON parse for per-instance config
	function safeJson(s){ try{ return s ? JSON.parse(s) : {}; } catch{ return {}; } }

	// Time formatter (12/24h based on cfg)
	function formatTime(d, use24h){
		const h  = d.getHours();
		const m  = pad2(d.getMinutes());
		if (use24h) return `${pad2(h)}:${m}`;
		const ampm = h >= 12 ? 'PM' : 'AM';
		const hh   = (h % 12) || 12;
		return `${hh}:${m} ${ampm}`;
	}

	// Ensure a provider script is loaded exactly once
	async function ensureScript(src, readyCheck, timeoutMs=8000){
		if (typeof window.loadExternalScriptOnce === 'function'){
			return window.loadExternalScriptOnce(src, readyCheck, timeoutMs);
		}
		if (readyCheck && readyCheck()) return;
		const s = document.createElement('script');
		s.src = src;
		document.head.appendChild(s);
		const t0 = Date.now();
		await new Promise((resolve, reject)=>{
			(function poll(){
				if (!readyCheck || readyCheck()) return resolve();
				if (Date.now()-t0 > timeoutMs) return reject(new Error('load timeout: '+src));
				setTimeout(poll, 80);
			})();
		});
	}

	function renderList(listEl, anchors, now, cfg){
		const rows = (anchors||[])
			.slice()
			.sort((a,b)=>a.at-b.at)
			.map(a=>{
				const label = a.label || a.id;
				const desc  = (a.desc ?? a.labelAr); // compatibility
				const tm    = formatTime(a.at, cfg.use24h);
				return `
					<div class="g-row" data-id="${a.id}">
						<div class="g-marker"></div>
						<div class="g-label">${label}${(cfg.showDesc && desc) ? ` (${desc})` : ''}</div>
						<div class="g-value">${tm}</div>
					</div>
				`;
			}).join('');
		listEl.innerHTML = rows;
	}

	window.GADGETS['runway-viewport'] = {
		info: 'Runway Viewport (blend/run renderer)',

		async mount(host, portalCtx){
			console.log('[Runway] mount called', { host, ctx: portalCtx });

			await window.ChronusReady;

			// Ensure baseline providers even if no other gadget loaded them.
			await ensureScript(
				'./providers/chronus_civil_provider.js',
				()=> !!window.__ChronusCivilProviderReady,
				12000
			);
			await ensureScript(
				'./providers/chronus_prayerTimes_provider.js',
				()=> !!window.__ChronusPrayerProviderReady,
				12000
			);

			// --- DOM scaffold first (so fineEl / listEl always exist) -----------------
			host.innerHTML = `
				<div class="gadget">
					<div class="hdr">
						<div class="title">Runway</div>
						<div class="fineprint" id="fine"></div>
					</div>
					<div id="list"></div>
				</div>
			`;
			const listEl  = host.querySelector('#list');
			const fineEl  = host.querySelector('#fine');
			const titleEl = host.querySelector('.title');
			if (titleEl) titleEl.textContent = '';	// Hide literal “Runway” label

			// If truly no providers, show friendly message and bail.
			if (!window.__ChronusCivilProviderReady && !window.__ChronusPrayerProviderReady){
				fineEl.textContent = '';
				listEl.innerHTML = '<div class="muted" style="padding:8px;">No Chronus providers. Enable Prayer Times / Civil.</div>';
				return;
			}

			// Start Chronus (safe no-op if already running)
			try { window.Chronus?.start?.(); } catch{}

			// ------------------------------------------------------------------
			// Chronus context bootstrap
			// ------------------------------------------------------------------
			let contexts = (window.Chronus.listContexts?.() || []);

			// If no contexts exist at all, try to synthesise one from portal settings.
			if (!contexts.length){
				const settings =
					(portalCtx && (portalCtx.settings || (portalCtx.getSettings && portalCtx.getSettings()))) || {};
				const pt =
					settings.prayerTimesChronus ||
					settings.prayerTimes ||
					settings.prayer ||
					{};

				const tz =
					pt.tz ||
					pt.timeZone ||
					((Intl.DateTimeFormat && Intl.DateTimeFormat().resolvedOptions().timeZone) || 'UTC');

				const label =
					pt.label ||
					pt.city ||
					pt.locationName ||
					'Local';

				const defCtx = { id: 'local', label, tz };
				if (typeof pt.lat === 'number')     defCtx.lat     = pt.lat;
				if (typeof pt.lng === 'number')     defCtx.lng     = pt.lng;
				if (typeof pt.country === 'string') defCtx.country = pt.country;
				if (typeof pt.method === 'string')  defCtx.method  = pt.method;
				if (typeof pt.asr === 'string')     defCtx.asr     = pt.asr;

				try {
					window.Chronus.addContext(defCtx);
				} catch (e){
					console.warn('[Runway] failed to add default Chronus context', e, defCtx);
				}
				contexts = (window.Chronus.listContexts?.() || []);
			}

			// If we *still* have no contexts, explain and stop.
			if (!contexts.length){
				fineEl.textContent = 'No Chronus contexts. Open Prayer Times / Settings to configure.';
				listEl.innerHTML   = '';
				console.warn('[Runway] No Chronus contexts found – nothing to render.');
				return;
			}

			// Ensure activeContextId + frame
			let state = window.Chronus.getState ? window.Chronus.getState() : {};
			if (!state.activeContextId){
				try {
					window.Chronus.setActiveContext && window.Chronus.setActiveContext(contexts[0].id);
				} catch(e){
					console.warn('[Runway] failed to set active Chronus context', e);
				}
				state = window.Chronus.getState ? window.Chronus.getState() : state;
			}
			if (!state.frame){
				try {
					window.Chronus.setFrame && window.Chronus.setFrame('daily');
				} catch(e){
					console.warn('[Runway] failed to set Chronus frame', e);
				}
			}

			// ------------------------------------------------------------------
			// Per-instance config (from gadget slot dataset)
			// ------------------------------------------------------------------
			const slot = host.closest('.gadget-slot');
			const cfg = {
				mode: 'blend',                 // 'blend' | 'run'
				contextId: null,               // bind to Chronus context or fallback to active
				frame: 'daily',                // 'daily'|'weekly'|'monthly'|'annual'
				categories: null,              // e.g., ['prayer','civil']
				use24h: false,                 // time format
				showDesc: true,                // show description in parentheses
				fineprintKeys: ['city','method','tz'],
				// optional for 'run' mode:
				anchors: null,                 // static array of anchors
				feedFn: null,                  // async () => ({ anchors, meta })
				...safeJson(slot?.dataset?.runway)
			};

			const MODE = (cfg.mode === 'run') ? 'run' : 'blend';

			// ------------------------------------------------------------------
			// Local state for this gadget instance
			// ------------------------------------------------------------------
			let latest       = [];   // anchors currently displayed (for “today”)
			let dayStart     = null; // Date (UTC) start of current day in context TZ
			let dayEnd       = null; // Date (UTC) end   of current day in context TZ
			let nextDayFirst = null; // first anchor of “tomorrow” (for post-last countdown)
			let lastPaintedKey = '';

			function structuralKey(list){
				return (list || []).map(a => `${a.id}@${a.at?.getTime?.()||0}`).join('|');
			}

			function computeDayWindow(now, ctx){
				const tzOffsetMin = (ctx && typeof ctx.tzOffsetMin === 'number')
					? ctx.tzOffsetMin
					: (-now.getTimezoneOffset()); // fallback: machine offset

				const DAY      = 24 * 60 * 60 * 1000;
				const nowUTC   = now.getTime();
				const localMs  = nowUTC + tzOffsetMin * 60000;
				const startLoc = Math.floor(localMs / DAY) * DAY;
				const startUTC = startLoc - tzOffsetMin * 60000;
				const endUTC   = startUTC + DAY;

				return { startUTC: new Date(startUTC), endUTC: new Date(endUTC), tzOffsetMin };
			}

			function applyCurrentAndCountdown(now){
				const { seq, current, next, phase } = resolveSlots(latest, now);

				// clear markers + any existing subline (do NOT rebuild rows)
				Array.from(listEl.querySelectorAll('.g-row')).forEach(el=>{
					el.classList.remove('active');
					const m = el.querySelector('.g-marker'); if (m) m.textContent = '';
					const sub = el.nextElementSibling;
					if (sub && sub.classList.contains('g-subvalue')) sub.remove();
				});

				if (!seq.length) return;

				const rowOf   = a => a && listEl.querySelector(`.g-row[data-id="${a.id}"]`);
				const first   = seq[0];
				const last    = seq[seq.length - 1];
				const firstEl = rowOf(first);
				const lastEl  = rowOf(last);

				if (phase === 'pre') {
					// PRE-FIRST (after midnight, before Fajr):
					// - Symbolic highlight on today's Isha (last visible row) with ▷
					// - Countdown should appear *after that symbolic row*, but target Fajr (first.at)
					if (lastEl){
						lastEl.classList.add('active');
						const m = lastEl.querySelector('.g-marker'); if (m) m.textContent = '▷';
						if (first?.at){
							const eta = Math.max(0, Math.floor((first.at - now)/1000));
							lastEl.insertAdjacentHTML('afterend', `
								<div class="g-subvalue">
									<span>⌛ Time left</span>
									<span>${fmtHMS(eta)}</span>
								</div>
							`);
						}
					}
					return;
				}

				if (next) {
					// BETWEEN anchors:
					// - Highlight true current with ▶
					// - Countdown to NEXT
					const curEl = rowOf(current);
					if (curEl){
						curEl.classList.add('active');
						const m = curEl.querySelector('.g-marker'); if (m) m.textContent = '▶';
						const eta = Math.max(0, Math.floor((next.at - now)/1000));
						curEl.insertAdjacentHTML('afterend', `
							<div class="g-subvalue">
								<span>⌛ Time left</span>
								<span>${fmtHMS(eta)}</span>
							</div>
						`);
					}
					return;
				}

				// POST-LAST:
				// - Highlight Isha with ▷
				// - Countdown to tomorrow's first if available
				if (lastEl){
					lastEl.classList.add('active');
					const m = lastEl.querySelector('.g-marker'); if (m) m.textContent = '▷';
					if (nextDayFirst?.at){
						const eta = Math.max(0, Math.floor((nextDayFirst.at - now)/1000));
						lastEl.insertAdjacentHTML('afterend', `
							<div class="g-subvalue">
								<span>⌛ Time left</span>
								<span>${fmtHMS(eta)}</span>
							</div>
						`);
					}
				}
			}

			function getMeta(){
				// Blend mode: derive from Chronus context
				if (MODE === 'blend' && window.Chronus.getState) {
					const st  = window.Chronus.getState();
					const ctx = (window.Chronus.listContexts?.() || [])
						.find(c => c.id === (cfg.contextId || st.activeContextId));
					return ctx || {};
				}
				// Run mode: allow the sequence/anchors supplier to attach meta
				if (latest?.meta) return latest.meta;   // e.g., { city:'Seattle', tz:'PST' }
				return {};
			}

			function renderFineprint(el){
				const meta  = getMeta();
				const parts = (cfg.fineprintKeys||[])
					.map(k => meta?.[k])
					.filter(Boolean);
				el.textContent = parts.length ? parts.join(' · ') : '';
			}

			function refreshFromBlend(){
				try{
					const st  = window.Chronus.getState ? window.Chronus.getState() : {};
					const ctx = (window.Chronus.listContexts?.() || [])
						.find(c => c.id === (cfg.contextId || st.activeContextId)) || {};
					const now = st.cursor ? new Date(st.cursor) : new Date();

					const win = computeDayWindow(now, ctx);
					dayStart  = win.startUTC;
					dayEnd    = win.endUTC;

					let all = window.Chronus.getAnchors
						? (window.Chronus.getAnchors({ contextId: ctx.id }) || [])
						: [];

					let todays = all.filter(a => a.at >= dayStart && a.at < dayEnd);

					const tomorrowCandidates = all
						.filter(a => a.at >= dayEnd && a.at < new Date(dayEnd.getTime() + 24*3600*1000))
						.sort((x,y)=>x.at - y.at);

					nextDayFirst = tomorrowCandidates[0] || null;
					latest       = todays.slice().sort((x,y)=>x.at - y.at);
				}catch(_){
					latest = [];
					nextDayFirst = null;
				}
			}

			async function refreshFromRun(){
				try{
					if (typeof cfg.feedFn === 'function'){
						const out = await cfg.feedFn();
						latest = (out?.anchors || []).slice().sort((a,b)=>a.at - b.at);
						latest.meta = out?.meta || null;
					}else if (Array.isArray(cfg.anchors)){
						latest = cfg.anchors.slice().sort((a,b)=>a.at - b.at);
					}else{
						latest = [];
					}
				}catch(_){
					latest = [];
				}
			}

			function recalcAndPaint(){
				const st  = window.Chronus.getState ? window.Chronus.getState() : {};
				const now = st.cursor ? new Date(st.cursor) : new Date();

				if (MODE === 'blend') refreshFromBlend();
				else                  refreshFromRun();

				renderFineprint(fineEl);

				const key = structuralKey(latest);
				if (key !== lastPaintedKey){
					renderList(listEl, latest, now, cfg);
					lastPaintedKey = key;
				}
				applyCurrentAndCountdown(now);
			}

			// Subscriptions
			const offBlend  = window.Chronus.on('chronus.blend.update',  ()=> recalcAndPaint());
			const offCursor = window.Chronus.on('chronus.cursor.change', ()=> recalcAndPaint());
			const offCtx    = window.Chronus.on('chronus.context.change',()=> recalcAndPaint());

			// Per-second path: update countdown; on day rollover, rebuild once
			const offTick = window.Chronus.on('chronus.anchor.tick', ()=>{
				const now = new Date();
				applyCurrentAndCountdown(now);
				if (dayEnd && now >= dayEnd){
					recalcAndPaint();
				}
			});

			// Initial paint
			try { window.Chronus.start && window.Chronus.start(); } catch(_){}
			recalcAndPaint();

			// Unmount hook
			return ()=>{
				offBlend && offBlend();
				offTick  && offTick();
				offCursor&& offCursor();
				offCtx   && offCtx();
			};
		}
	};
})();
