/*==============================================================================
| Runway Viewport (Renderer)
| File: gadgets/runway-viewport.js
| Tabs: hard tabs
|
| 1) Purpose
|	- Display either:
|		(a) a blended slice from providers (e.g., Civil + PrayerTimes), or
|		(b) a run (anchors generated by ChronusRunner).
|
| 2) Modes
|	- mode: 'blend' (default) → uses Chronus blended list for active context/frame.
|	- mode: 'run' → expects an injected anchors array (or a function) via window.RUNWAY_FEED().
|
| 3) UI
|	- Title + fineprint (city).
|	- List of anchors for the active frame.
|	- CURRENT row gets ▷ and inline "⌛ Time Left: H:MM:SS" until NEXT.
|
| 4) Integration
|	- Subscribes to: chronus.blend.update, chronus.anchor.tick, chronus.cursor.change, chronus.context.change
|	- No providers are registered here; this is a pure renderer.
|
| ★ Future hooks
|	- Progress bars for day/week windows.
|	- Grouping by category (civil/prayer/run).
==============================================================================*/
(function(){
	if (!window.GADGETS) window.GADGETS = {};

	function pad2(n){ return (n<10?'0':'')+n; }

	function resolveSlots(anchors, now){
		const seq = (anchors||[]).slice().sort((a,b)=>a.at-b.at);
		let current=null, next=null, prev=null;
		for (let i=0;i<seq.length;i++){
			const a = seq[i];
			if (a.at <= now) { prev = a; current = a; }
			if (a.at > now){ next = a; break; }
		}
		// Special case: if current is the last, next stays null
		return { seq, prev, current, next };
	}

	function fmtHMS(sec){
		const s = Math.max(0, sec|0);
		const h = Math.floor(s/3600);
		const m = Math.floor((s%3600)/60);
		const ss = s%60;
		return `${h}:${pad2(m)}:${pad2(ss)}`;
	}

	function renderList(listEl, anchors, now){
		// does not appear to use 'now' directly, but kept for future use
		const rows = (anchors||[])
			.slice()
			.sort((a,b)=>a.at-b.at)
			.map(a=>{
			const en = a.label || a.id;
			const ar = a.labelAr ? ` (${a.labelAr})` : '';
			const tm = `${pad2(a.at.getHours())}:${pad2(a.at.getMinutes())}`;
			return `
				<div class="g-row" data-id="${a.id}">
				<div class="g-marker"></div>
				<div class="g-label">${en}${ar}</div>
				<div class="g-value">${tm}</div>
				</div>
			`;
			}).join('');
		listEl.innerHTML = rows;
	}

	window.GADGETS['runway-viewport'] = {
		info: 'Runway Viewport (blend/run renderer)',

		async mount(host){
			await window.ChronusReady;

			host.innerHTML = `
				<div class="gadget">
					<div class="hdr">
						<div class="title">Runway</div>
						<div class="fineprint" id="fine"></div>
					</div>
					<div id="list"></div>
				</div>
			`;
			const listEl = host.querySelector('#list');
			const fineEl = host.querySelector('#fine');

			// Mode decision: default 'blend'; allow external to set window.RUNWAY_MODE and window.RUNWAY_FEED
			const MODE = (window.RUNWAY_MODE === 'run') ? 'run' : 'blend';

			let latest = [];	// anchors currently displayed

			function paint(now){
				renderList(listEl, latest, now);
				const { current, next } = resolveSlots(latest, now);

				// clear current markers + any prior sublines
				Array.from(listEl.querySelectorAll('.g-row')).forEach(el=>{
					el.classList.remove('active');
					const m = el.querySelector('.g-marker'); if (m) m.textContent = '';
					const maybeSub = el.nextElementSibling;
					if (maybeSub && maybeSub.classList.contains('g-subvalue')) maybeSub.remove();
				});

				if (!current) return;

				// activate current
				const row = listEl.querySelector(`.g-row[data-id="${current.id}"]`);
				if (!row) return;

				row.classList.add('active');
				const m = row.querySelector('.g-marker'); if (m) m.textContent = '▶';

				// add countdown line as a sibling (keeps time right-aligned & grey)
				if (next){
					const etaSecs = Math.max(0, Math.floor((next.at - now)/1000));
					row.insertAdjacentHTML('afterend', `
					<div class="g-subvalue">
						<span>⌛ Time left</span>
						<span>${fmtHMS(etaSecs)}</span>
					</div>
					`);
				}
			}

			function updateFineprint(){
				try{
					const st = window.Chronus.getState ? window.Chronus.getState() : {};
					const ctxs = window.Chronus.listContexts ? window.Chronus.listContexts() : [];
					const ctx = ctxs.find(c=>c.id===st.activeContextId) || ctxs[0] || {};
					fineEl.textContent = ctx && ctx.city ? ctx.city : 'Current Location';
				}catch(_){}
			}

			// Feed resolution
			function refreshFromBlend(){
				try{
					const st = window.Chronus.getState ? window.Chronus.getState() : {};
					const ctxId = st.activeContextId;
					const frame = st.frame || 'daily';
					latest = (window.Chronus.getAnchors({ contextId: ctxId, frame }) || []).slice().sort((a,b)=>a.at-b.at);
				}catch(_){ latest = []; }
			}
			async function refreshFromRun(){
				try{
					if (typeof window.RUNWAY_FEED === 'function'){
						latest = await window.RUNWAY_FEED();
					}else if (Array.isArray(window.RUNWAY_FEED)){
						latest = window.RUNWAY_FEED.slice();
					}else{
						latest = [];
					}
					latest.sort((a,b)=>a.at-b.at);
				}catch(_){ latest = []; }
			}

			function recalcAndPaint(){
				const now = new Date();
				if (MODE === 'blend') refreshFromBlend();
				else refreshFromRun();
				updateFineprint();
				paint(now);
			}

			// Subscriptions
			const offBlend  = window.Chronus.on('chronus.blend.update',	()=>recalcAndPaint());
			const offTick   = window.Chronus.on('chronus.anchor.tick',	()=>recalcAndPaint());
			const offCursor = window.Chronus.on('chronus.cursor.change',	()=>recalcAndPaint());
			const offCtx    = window.Chronus.on('chronus.context.change',	()=>recalcAndPaint());

			// First paint
			try { window.Chronus.start && window.Chronus.start(); } catch(_){}
			recalcAndPaint();

			return ()=>{ offBlend&&offBlend(); offTick&&offTick(); offCursor&&offCursor(); offCtx&&offCtx(); };
		}
	};
})();
